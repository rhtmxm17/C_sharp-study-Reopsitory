# 알고리즘

## 재귀와 알고리즘

재귀 함수를 통해 직관적으로 쉽게 작성할 수 있는 경우가 많다. 하지만 재귀는 함수 호출을 동반하기 때문에 함수 호출의 비용과 스택 오버플로우 등의 위험성이 존재한다. 따라서 트리 구조에서의 사용과 같이 반복문보다 재귀로 호출하는게 매우 직관적인 경우나, 재귀를 통해 시간 복잡도를 줄일 수 있는 경우에 사용하는 것이 적합하다.

## 정렬 알고리즘

### 버블 정렬

앞에서부터 값을 2개씩 비교해서 큰 값을 뒤로 보내는 것으로 가장 큰 값을 가장 뒤로 보낸다. 이 작업을 가장 뒤에서부터 가장 큰 값 부터 채워나가는 형태로 반복한다.
O(n)의 작업을 n만큼 반복했기 때문에 O(n<sup>2</sup>)의 시간 복잡도를 갖는다.

### 선택 정렬

버블 정렬에서 값을 2개씩 교환하는 대신, 전체에서 최대값/최소값을 찾아 맨 뒤/앞의 값과 교환하는 것으로 값 교환 횟수를 줄인 방식. 매 회차 최대값/최소값을 찾는 작업(O(n))이 필요하므로 시간 복잡도는 마찬가지로 O(n<sup>2</sup>)이다.

### 삽입 정렬

데이터를 정렬된 영역과 정렬되지 않은 영역으로 나눠서 정렬되지 않은 영역의 데이터를 정렬된 영역에 하나씩 끼워넣는 정렬 방식. 매 회차 끼워 넣을 위치를 찾아 순회하는 작업이 필요하므로 시간 복잡도는 O(n<sup>2</sup>)이다.

### 퀵 정렬

임의의 기준값(pivot, 일반적인 예시에서는 가장 앞이나 뒤에 위치한 값을 사용)를 잡아서 그보다 작은 값을 앞에, 큰 값을 뒤에 몰아넣기를 재귀적으로 반복하는 방식. 한번의 작업 결과로

1. 기준값은 최종적으로 정렬되었을 떄의 자리를 찾아간다.
2. 기준값보다 작은 값, 큰 값만 모인 두 개의 데이터로 나뉜다.

매 단계마다 데이터를 순회하므로 한 단계의 작업은 O(n) 그대로 이지만, 데이터 묶음이 절반 크기로 줄어들기 때문에 작업 횟수가 O(log n)으로 줄어들어 평균적으로 O(n log n)의 시간 복잡도를 갖는다.

다만, 이미 일정 이상 정렬 되어있는 경우와 같이 pivot이 가장 크거나 작은 값이 자주 잡히게 된다면 작업 횟수가 n에 근접하기 때문에 최악의 경우 O(n<sup>2</sup>)의 효율을 보이기 때문에, 최악의 경우가 발생할 가능성을 낮추기 위해 가장 앞, 뒤, 중앙의 세 값중 크기가 중간인 값을 사용하는 등의 대처법을 사용한다.

### 병합 정렬

데이터 묶음을 더이상 나눌 수 없을 때 까지 반으로 나누고, 다시 두 묶음씩 정렬하면서 병합한다. 병합할 때에 각 묶음은 이미 정렬되어 있으므로, 두 묶음의 가장 앞의 값만 비교하면 두 묶음 모두에서 가장 작은 값을 추출할 수 있다. 따라서 병합 과정에서 순회는 한번만 일어난다.  
병합은 O(log n)만큼 일어나므로 O(n log n)의 시간 복잡도를 갖는다.

### 힙 정렬

주어진 데이터를 힙 자료구조로 구성(또는 취급)하고, 힙에서 원소를 하나씩 꺼내서 정렬된 순서로 배열한다.  
[시각화 링크](https://www.cs.usfca.edu/~galles/visualization/HeapSort.html)  
이 링크에서 쉽게 볼 수 있듯이 사용하는 메모리 위치가 이곳 저곳을 오가기때문에 데이터의 크기가 커질수록 메모리 지역성을 크게 해친다. 때문에 이론상으로는 O(n log n)의 시간 복잡도를 보장하지만 실제 속도는 평균 시간 복잡도의 퀵 정렬, 병합 정렬보다 일반적으로 느리다.

### 분류: 안정 정렬과 불안정 정렬

보드게임 카드를 공격력 순서로 정렬한 다음, 레벨 순서로 정렬하는 경우를 떠올리자. 이때 같은 레벨일 경우 공격력 순서로 정렬되어 있는 것이 안정 정렬, 그렇지 않은 것이 불안정 정렬이다.  
병합 정렬은 C#에서 일반적으로 퀵 정렬보다 느리지만, 안정 정렬이라는 특징이 있다.

### 혼합: 인트로 정렬(introsort)

C#과 C++에서 기본으로 사용하는 정렬 알고리즘이다. 퀵 정렬, 힙 정렬, 삽입 정렬을 혼합한 방식이다. 퀵 정렬의 재귀 횟수가 일정 이상이 될 경우 힙 정렬로 전환하고, 원소 개수가 일정 이하가 될 경우 삽입 정렬로 전환한다.

### 혼합: 팀 정렬(Timsort)

병합 정렬과 삽입 정렬을 혼합해서 안정 정렬을 유지하면서 작은 단위에서의 속도를 올린 정렬 방식이다.

## 탐색 알고리즘(순회)

### 선형 탐색

가장 단순하고 모든 순회 가능한 자료구조에 적용 가능한 탐색 방식. 가장 앞에서부터 하나씩 넘어가면서 찾고자 하는 원소가 맞는지 확인한다.

### 이진 탐색

정렬 되어있는 데이터에서 적용 가능한 탐색 방식. 데이터의 중간값을 검사해서 찾고자 하는 데이터보다 큰지, 작은지에 따라 앞쪽 절반 또는 뒤쪽 절반에 대해 다시 중간값 검사하기를 반복한다. 매 시도마다 검사할 남은 데이터가 절반으로 줄어들기 때문에 시간 복잡도는 O(log n)이다.

### 그래프에서의 탐색

트리형 그래프가 아니라면 탐색 과정에서 이미 방문한 노드인지 여부를 기록해야 한다.

#### 깊이 우선 탐색(DFS, Depth-First Search)

최대한 깊이 탐색한 뒤, 더이상 들어갈 수 없으면 돌아가서 다른 분기를 탐색하는 방식. 탐색을 미룬 분기를 스택에 담아두었다가 다른 분기를 탐색해야되는 시점에서 하나씩 꺼내는 방식으로 구현하는 방법을 예로 들 수 있다.

최단 경로를 보장하지 못하지만 적은 메모리 사용량으로 구현이 가능하다.

#### 너비 우선 탐색(Breath-First Search)

최대한 넓게 탐색한 뒤, 더이상 갈 수 없을 경우 다음 단계로 이동하는 방식. 시작 노드에서 직접 연결된 모든 노드(1차)를 탐색한 뒤, 1차에 연결된 모든 노드(2차)를 탐색하기를 차수를 올려가며 반복한다.  
앞으로 탐색해야 할 노드를 큐에 저장하는 방식으로 구현하는 방법을 예로 들 수 있다.

최단 경로를 보장하지만 큐에 사용할 많은 메모리를 필요로 한다.

## 길찾기 알고리즘

그래프에서 목적지까지의 최단 경로를 계산하는 알고리즘. 가중치가 있다면 경로상의 가중치 합계가 가장 작은 경로가 최단 경로이다.

### 다익스트라 알고리즘

출발 노드에서 가장 가까운 노드를 순서대로 확인해 나가는 방식. 지금까지 확인한 모든 노드에 인접한 노드중 (누적 거리 + 인접 거리)가 가장 작은 노드부터 확인해 나간다.  
각 노드마다 어느 노드의 인접 노드로 확인되었는지 기록해서 기록을 타고 가는 것으로 최단경로를 얻을 수 있다.

### A* 알고리즘

다익스트라 알고리즘을 예상 거리 기반으로 개선한 길찾기 알고리즘  
다익스트라 알고리즘은 누적 이동 거리가 가장 짧은 노드에서 인접 노드를 검색했지만 A*에서는 누적 거리 + 예상 잔여 거리(휴리스틱)가 가장 짧은 노드에서 인접 노드를 검색한다.

A* 알고리즘의 성능은 휴리스틱의 효율성에 큰 영향을 받는다.
